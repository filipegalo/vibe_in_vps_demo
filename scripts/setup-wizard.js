#!/usr/bin/env node

/**
 * Interactive Setup Wizard for vibe_in_vps
 *
 * Guides users through the setup process step-by-step
 * with navigation, progress tracking, and helpful links.
 */

const readline = require('readline');
const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs');
const path = require('path');
const execAsync = promisify(exec);
const crypto = require('crypto');

// Configuration file path
const CONFIG_FILE = path.join(process.cwd(), '.setup-config.json');

// Load configuration
function loadConfig() {
  const defaultConfig = {
    databases: {
      postgresql: false,
      mysql: false,
      redis: false,
    },
    ssh: {
      enableDirectAccess: false,
      userIp: '',
    },
    cloudflare: {
      enabled: false,
      domainName: '',
      apiToken: '',
      accountId: '',
      zoneId: '',
    },
  };

  try {
    if (fs.existsSync(CONFIG_FILE)) {
      const data = fs.readFileSync(CONFIG_FILE, 'utf8');
      const loadedConfig = JSON.parse(data);

      // Merge with defaults to ensure all properties exist (backward compatibility)
      return {
        databases: {
          ...defaultConfig.databases,
          ...(loadedConfig.databases || {}),
        },
        ssh: {
          ...defaultConfig.ssh,
          ...(loadedConfig.ssh || {}),
        },
        cloudflare: {
          ...defaultConfig.cloudflare,
          ...(loadedConfig.cloudflare || {}),
        },
      };
    }
  } catch (error) {
    console.error('Warning: Could not load config file:', error.message);
  }

  return defaultConfig;
}

// Save configuration
function saveConfig(config) {
  try {
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2), 'utf8');
  } catch (error) {
    console.error('Warning: Could not save config file:', error.message);
  }
}

// Update terraform.tfvars with SSH IP if configured
function updateTerraformVars(config) {
  const tfvarsPath = path.join(process.cwd(), 'infra', 'terraform', 'terraform.tfvars');
  const tfvarsDir = path.dirname(tfvarsPath);

  try {
    // Ensure directory exists
    if (!fs.existsSync(tfvarsDir)) {
      console.log(`\n${colors.yellow}Note: Terraform directory doesn't exist yet. Will save for later.${colors.reset}\n`);
      return;
    }

    let content = '';

    // Read existing terraform.tfvars if it exists
    if (fs.existsSync(tfvarsPath)) {
      content = fs.readFileSync(tfvarsPath, 'utf8');
    } else {
      // Create header for new file
      content = '# Terraform Variables\n# Generated by setup wizard\n\n';
    }

    // Check if additional_ssh_ips line exists
    const sshIpsRegex = /^additional_ssh_ips\s*=\s*.*/gm;
    const hasUserIp = config.ssh.enableDirectAccess && config.ssh.userIp;

    if (hasUserIp) {
      const newLine = `additional_ssh_ips = ["${config.ssh.userIp}"]`;

      if (sshIpsRegex.test(content)) {
        // Replace existing line
        content = content.replace(sshIpsRegex, newLine);
      } else {
        // Add new line at the end
        if (!content.endsWith('\n')) content += '\n';
        content += `\n# SSH access for your IP (configured via setup wizard)\n${newLine}\n`;
      }
    } else {
      // Remove or comment out the line if SSH is disabled
      if (sshIpsRegex.test(content)) {
        content = content.replace(sshIpsRegex, '# additional_ssh_ips = []  # Disabled in wizard');
      }
    }

    // Handle Cloudflare configuration (non-sensitive values only)
    // API token goes to GitHub Secrets, not terraform.tfvars
    const cloudflareRegex = /^(cloudflare_zone_id|domain_name)\s*=\s*.*/gm;

    if (config.cloudflare.enabled && config.cloudflare.domainName) {
      // Remove existing Cloudflare lines
      content = content.replace(cloudflareRegex, '');

      // Add new Cloudflare configuration block (non-sensitive only)
      if (!content.endsWith('\n')) content += '\n';
      content += '\n# Cloudflare Configuration (configured via setup wizard)\n';
      content += `# Note: CLOUDFLARE_API_TOKEN is in GitHub Secrets, not this file\n`;
      content += `cloudflare_zone_id = "${config.cloudflare.zoneId}"\n`;
      content += `domain_name        = "${config.cloudflare.domainName}"\n`;
    } else {
      // Remove Cloudflare lines if disabled
      content = content.replace(cloudflareRegex, '');
    }

    // Write back
    if (content) {
      fs.writeFileSync(tfvarsPath, content, 'utf8');
    }
  } catch (error) {
    console.error('Warning: Could not update terraform.tfvars:', error.message);
  }
}

// SSH key management
const SSH_DIR = path.join(process.cwd(), '.ssh');
const PRIVATE_KEY_PATH = path.join(SSH_DIR, 'id_ed25519');
const PUBLIC_KEY_PATH = path.join(SSH_DIR, 'id_ed25519.pub');

function sshKeysExist() {
  return fs.existsSync(PRIVATE_KEY_PATH) && fs.existsSync(PUBLIC_KEY_PATH);
}

async function generateSSHKeys() {
  try {
    // Create .ssh directory if it doesn't exist
    if (!fs.existsSync(SSH_DIR)) {
      fs.mkdirSync(SSH_DIR, { mode: 0o700 });
    }

    // Delete existing keys if they exist (to avoid ssh-keygen's interactive prompt)
    if (fs.existsSync(PRIVATE_KEY_PATH)) {
      fs.unlinkSync(PRIVATE_KEY_PATH);
    }
    if (fs.existsSync(PUBLIC_KEY_PATH)) {
      fs.unlinkSync(PUBLIC_KEY_PATH);
    }

    // Generate ED25519 key pair using ssh-keygen
    await execAsync(`ssh-keygen -t ed25519 -f "${PRIVATE_KEY_PATH}" -N "" -C "vibe_in_vps_deploy_key"`);

    // Set proper permissions
    fs.chmodSync(PRIVATE_KEY_PATH, 0o600);
    fs.chmodSync(PUBLIC_KEY_PATH, 0o644);

    return true;
  } catch (error) {
    console.error('Failed to generate SSH keys:', error.message);
    return false;
  }
}

function getSSHKeys() {
  try {
    const privateKey = fs.readFileSync(PRIVATE_KEY_PATH, 'utf8');
    const publicKey = fs.readFileSync(PUBLIC_KEY_PATH, 'utf8');
    return { privateKey, publicKey };
  } catch (error) {
    return null;
  }
}

// Apply database and Cloudflare configuration to docker-compose.yml
function applyDatabaseConfig() {
  const composePath = path.join(process.cwd(), 'deploy', 'docker-compose.yml');

  try {
    if (!fs.existsSync(composePath)) {
      return; // File doesn't exist, skip
    }

    let content = fs.readFileSync(composePath, 'utf8');
    const lines = content.split('\n');
    const result = [];

    let currentBlock = null;

    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      const trimmed = line.trim();

      // Detect block markers
      if (trimmed === '# [POSTGRES_START]') {
        currentBlock = 'postgres';
      } else if (trimmed === '# [POSTGRES_END]') {
        currentBlock = null;
      } else if (trimmed === '# [MYSQL_START]') {
        currentBlock = 'mysql';
      } else if (trimmed === '# [MYSQL_END]') {
        currentBlock = null;
      } else if (trimmed === '# [REDIS_START]') {
        currentBlock = 'redis';
      } else if (trimmed === '# [REDIS_END]') {
        currentBlock = null;
      } else if (trimmed === '# [CLOUDFLARE_START]') {
        currentBlock = 'cloudflare';
      } else if (trimmed === '# [CLOUDFLARE_END]') {
        currentBlock = null;
      } else if (trimmed === '# [DB_ENV_START] - Auto-managed by setup wizard') {
        currentBlock = 'env';
      } else if (trimmed === '# [DB_ENV_END]') {
        currentBlock = null;
      } else if (trimmed === '# [DB_DEPENDS_START] - Auto-managed by setup wizard') {
        currentBlock = 'depends';
      } else if (trimmed === '# [DB_DEPENDS_END]') {
        currentBlock = null;
      } else if (trimmed === '# [DB_VOLUMES_START] - Auto-managed by setup wizard') {
        currentBlock = 'volumes';
      } else if (trimmed === '# [DB_VOLUMES_END]') {
        currentBlock = null;
      }

      // Uncomment or comment lines in database and Cloudflare blocks
      const isMarkerLine = trimmed.includes('[POSTGRES_') || trimmed.includes('[MYSQL_') || trimmed.includes('[REDIS_') || trimmed.includes('[CLOUDFLARE_');

      if (currentBlock === 'postgres' && !isMarkerLine && line.startsWith('  #')) {
        if (config.databases.postgresql) {
          line = line.replace(/^  # /, '  ');
        }
      } else if (currentBlock === 'postgres' && !isMarkerLine && line.startsWith('  ') && !line.startsWith('  #')) {
        if (!config.databases.postgresql && trimmed) {
          line = line.replace(/^  /, '  # ');
        }
      }

      if (currentBlock === 'mysql' && !isMarkerLine && line.startsWith('  #')) {
        if (config.databases.mysql) {
          line = line.replace(/^  # /, '  ');
        }
      } else if (currentBlock === 'mysql' && !isMarkerLine && line.startsWith('  ') && !line.startsWith('  #')) {
        if (!config.databases.mysql && trimmed) {
          line = line.replace(/^  /, '  # ');
        }
      }

      if (currentBlock === 'redis' && !isMarkerLine && line.startsWith('  #')) {
        if (config.databases.redis) {
          line = line.replace(/^  # /, '  ');
        }
      } else if (currentBlock === 'redis' && !isMarkerLine && line.startsWith('  ') && !line.startsWith('  #')) {
        if (!config.databases.redis && trimmed) {
          line = line.replace(/^  /, '  # ');
        }
      }

      // Cloudflare tunnel service
      if (currentBlock === 'cloudflare' && !isMarkerLine && line.startsWith('  #')) {
        if (config.cloudflare.enabled) {
          line = line.replace(/^  # /, '  ');
        }
      } else if (currentBlock === 'cloudflare' && !isMarkerLine && line.startsWith('  ') && !line.startsWith('  #')) {
        if (!config.cloudflare.enabled && trimmed) {
          line = line.replace(/^  /, '  # ');
        }
      }

      // Handle environment variables
      if (currentBlock === 'env') {
        if (trimmed.includes('DATABASE_URL=')) {
          if (config.databases.postgresql && line.match(/^\s*#/)) {
            line = line.replace(/^(\s*)# /, '$1');
          } else if (!config.databases.postgresql && !line.match(/^\s*#/) && line.includes('DATABASE_URL')) {
            line = line.replace(/^(\s*)/, '$1# ');
          }
        } else if (trimmed.includes('MYSQL_URL=')) {
          if (config.databases.mysql && line.match(/^\s*#/)) {
            line = line.replace(/^(\s*)# /, '$1');
          } else if (!config.databases.mysql && !line.match(/^\s*#/) && line.includes('MYSQL_URL')) {
            line = line.replace(/^(\s*)/, '$1# ');
          }
        } else if (trimmed.includes('REDIS_URL=')) {
          if (config.databases.redis && line.match(/^\s*#/)) {
            line = line.replace(/^(\s*)# /, '$1');
          } else if (!config.databases.redis && !line.match(/^\s*#/) && line.includes('REDIS_URL')) {
            line = line.replace(/^(\s*)/, '$1# ');
          }
        }
      }

      // Handle depends_on
      if (currentBlock === 'depends') {
        const hasAnyDb = config.databases.postgresql || config.databases.mysql || config.databases.redis;

        if (trimmed === '# depends_on:' || trimmed === 'depends_on:') {
          if (hasAnyDb && line.match(/^\s*#/)) {
            line = line.replace(/^(\s*)# /, '$1');
          } else if (!hasAnyDb && !line.match(/^\s*#/)) {
            line = line.replace(/^(\s*)/, '$1# ');
          }
        } else if (line.match(/^\s+#?\s*(postgres|mysql|redis):|condition:/)) {
          const isPostgres = line.includes('postgres');
          const isMysql = line.includes('mysql');
          const isRedis = line.includes('redis');
          const isCondition = trimmed.startsWith('condition:') || trimmed.startsWith('# condition:');

          // Check if previous line indicates which DB this belongs to
          let dbType = null;
          if (isCondition && i > 0) {
            if (lines[i-1].includes('postgres')) dbType = 'postgresql';
            else if (lines[i-1].includes('mysql')) dbType = 'mysql';
            else if (lines[i-1].includes('redis')) dbType = 'redis';
          }

          const shouldUncomment = (isPostgres && config.databases.postgresql) ||
                                 (isMysql && config.databases.mysql) ||
                                 (isRedis && config.databases.redis) ||
                                 (isCondition && dbType && config.databases[dbType]);

          if (shouldUncomment && line.match(/^\s*#/)) {
            line = line.replace(/^(\s*)# /, '$1');
          } else if (!shouldUncomment && !line.match(/^\s*#/) && trimmed) {
            line = line.replace(/^(\s*)/, '$1# ');
          }
        }
      }

      // Handle volumes
      if (currentBlock === 'volumes') {
        const hasAnyDb = config.databases.postgresql || config.databases.mysql || config.databases.redis;

        if (trimmed === '# volumes:' || trimmed === 'volumes:') {
          if (hasAnyDb && line.startsWith('#')) {
            line = line.replace(/^# /, '');
          } else if (!hasAnyDb && !line.startsWith('#')) {
            line = line.replace(/^/, '# ');
          }
        } else if (trimmed.includes('postgres-data:')) {
          if (config.databases.postgresql && line.startsWith('#')) {
            line = line.replace(/^# /, '');
          } else if (!config.databases.postgresql && !line.startsWith('#') && trimmed) {
            line = line.replace(/^/, '# ');
          }
        } else if (trimmed.includes('mysql-data:')) {
          if (config.databases.mysql && line.startsWith('#')) {
            line = line.replace(/^# /, '');
          } else if (!config.databases.mysql && !line.startsWith('#') && trimmed) {
            line = line.replace(/^/, '# ');
          }
        } else if (trimmed.includes('redis-data:')) {
          if (config.databases.redis && line.startsWith('#')) {
            line = line.replace(/^# /, '');
          } else if (!config.databases.redis && !line.startsWith('#') && trimmed) {
            line = line.replace(/^/, '# ');
          }
        }
      }

      result.push(line);
    }

    // Write back to file
    fs.writeFileSync(composePath, result.join('\n'), 'utf8');
  } catch (error) {
    console.error('Warning: Could not update docker-compose.yml:', error.message);
  }
}

// ANSI color codes
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  cyan: '\x1b[36m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
};

// Setup steps
const steps = [
  {
    title: 'Welcome to vibe_in_vps Setup',
    content: `
${colors.bright}Zero-ops deployment for your Dockerized apps${colors.reset}

This wizard will guide you through setting up your VPS deployment pipeline.

${colors.cyan}What you'll set up:${colors.reset}
  â€¢ GitHub repository (fork)
  â€¢ Hetzner Cloud VPS
  â€¢ GitHub Actions CI/CD
  â€¢ Optional: healthchecks.io monitoring
  â€¢ Optional: Custom domain with HTTPS

${colors.cyan}Time required:${colors.reset} 5-10 minutes

${colors.yellow}Prerequisites:${colors.reset}
  â€¢ GitHub account
  â€¢ Hetzner Cloud account
  â€¢ SSH key pair (we'll help you generate one)

Press ${colors.green}[Next]${colors.reset} to begin!
    `,
  },
  {
    title: 'Step 1: Fork the Repository',
    content: `
${colors.cyan}Fork the vibe_in_vps repository to your GitHub account${colors.reset}

1. Open your browser and go to:
   ${colors.blue}https://github.com/filipegalo/vibe_in_vps${colors.reset}

2. Click the ${colors.bright}"Fork"${colors.reset} button in the top-right corner

3. Select your account as the destination

4. Wait for the fork to complete

${colors.green}âœ“ Checkpoint:${colors.reset} You now have your own copy of the repository

${colors.dim}Tip: You can customize the repository name if you want!${colors.reset}
    `,
  },
  {
    title: 'Step 2: Create Required Accounts',
    content: `
${colors.cyan}Set up accounts for the services you'll need${colors.reset}

${colors.bright}1. GitHub Account${colors.reset} (if you don't have one)
   â†’ https://github.com/signup

${colors.bright}2. Hetzner Cloud Account${colors.reset} ${colors.yellow}(Required)${colors.reset}
   â†’ https://console.hetzner.cloud/
   â†’ Sign up and verify your email
   â†’ Add payment method (you won't be charged yet)

${colors.bright}3. healthchecks.io Account${colors.reset} ${colors.dim}(Optional - for monitoring)${colors.reset}
   â†’ https://healthchecks.io/
   â†’ Free tier includes 20 checks

${colors.bright}4. Cloudflare Account${colors.reset} ${colors.dim}(Optional - for custom domain + HTTPS)${colors.reset}
   â†’ https://cloudflare.com/
   â†’ Free tier works perfectly
   â†’ Add your domain and change nameservers

${colors.green}âœ“ Checkpoint:${colors.reset} All accounts created and verified
    `,
  },
  {
    title: 'Step 3: Generate SSH Keys',
    content: () => {
      const keysExist = sshKeysExist();

      if (keysExist) {
        const keys = getSSHKeys();
        return `
${colors.cyan}SSH keys found!${colors.reset}

${colors.green}âœ“ SSH keys already exist in project directory${colors.reset}

${colors.bright}Public key:${colors.reset}
${colors.dim}${keys.publicKey.trim()}${colors.reset}

${colors.bright}Private key location:${colors.reset} ${colors.dim}.ssh/id_ed25519${colors.reset}

${colors.yellow}Keys:${colors.reset}
  ${colors.green}[G]${colors.reset} Generate new keys (overwrites existing)
  ${colors.blue}[V]${colors.reset} View keys again

${colors.dim}Tip: These keys are auto-managed and will be used in Step 7${colors.reset}
`;
      } else {
        return `
${colors.cyan}Create SSH keys for secure server access${colors.reset}

${colors.yellow}Option 1: Automatic Generation (Recommended)${colors.reset}
  ${colors.green}Press [G] to generate keys automatically${colors.reset}
  â€¢ Keys saved to project directory (.ssh/)
  â€¢ Automatically used in later steps
  â€¢ Added to .gitignore for security

${colors.yellow}Option 2: Manual Generation${colors.reset}
  Run this command in your terminal:

  ${colors.dim}ssh-keygen -t ed25519 -C "your_email@example.com"${colors.reset}

  â€¢ Press Enter to accept default location
  â€¢ ${colors.bright}Leave passphrase empty${colors.reset} (press Enter twice)

${colors.bright}View your public key:${colors.reset}
  ${colors.dim}cat ~/.ssh/id_ed25519.pub${colors.reset}

${colors.green}âœ“ Checkpoint:${colors.reset} SSH keys generated

${colors.dim}Note: Keep your private key secret!${colors.reset}
`;
      }
    },
  },
  {
    title: 'Step 4: Optional Database Selection',
    content: () => `
${colors.cyan}Select databases you want to include (optional)${colors.reset}

Toggle databases on/off using the keys below. All are ${colors.bright}optional${colors.reset}.

${getDatabaseSelectionDisplay()}

${colors.bright}What happens when you toggle:${colors.reset}
  â€¢ ${colors.green}âœ“${colors.reset} Automatically uncomments services in docker-compose.yml
  â€¢ ${colors.green}âœ“${colors.reset} Enables database connection strings
  â€¢ ${colors.green}âœ“${colors.reset} Configures health checks and dependencies

${colors.bright}About Database Support:${colors.reset}
  â€¢ Databases run in Docker containers on your VPS
  â€¢ Connected via internal network (secure, no external ports)
  â€¢ Includes automatic backup scripts

${colors.yellow}Keys:${colors.reset}
  ${colors.green}[1]${colors.reset} Toggle PostgreSQL  ${colors.green}[2]${colors.reset} Toggle MySQL  ${colors.green}[3]${colors.reset} Toggle Redis

${colors.dim}Tip: You can change this later by re-running the wizard${colors.reset}
    `,
  },
  {
    title: 'Step 5: Configure SSH Access',
    content: () => `
${colors.cyan}SSH access security configuration${colors.reset}

${colors.bright}Security Default:${colors.reset}
SSH access is ${colors.green}automatically restricted to GitHub Actions${colors.reset} IP ranges only.
This prevents unauthorized access to your VPS.

${colors.bright}Do you need direct SSH access?${colors.reset}
If you want to SSH directly from your computer for troubleshooting, you can
add your IP address to the whitelist.

${colors.bright}Current Configuration:${colors.reset}
  Direct SSH Access: ${config.ssh.enableDirectAccess ? `${colors.green}Enabled${colors.reset}` : `${colors.dim}Disabled${colors.reset}`}
${config.ssh.userIp ? `  Your IP: ${colors.cyan}${config.ssh.userIp}${colors.reset}\n  ${colors.green}âœ“ Saved to terraform.tfvars${colors.reset}` : ''}

${colors.bright}Your Current IP Address:${colors.reset}
  Run this command to find your IP: ${colors.dim}curl ifconfig.me${colors.reset}

${colors.yellow}Keys:${colors.reset}
  ${colors.green}[E]${colors.reset} Enable/Disable direct SSH access
  ${colors.blue}[I]${colors.reset} Set your IP address (when enabled)

${colors.dim}Note: GitHub Actions will always have SSH access regardless of this setting${colors.reset}

${colors.bright}Recommendation:${colors.reset}
  â€¢ ${colors.green}Enable${colors.reset} if you need to troubleshoot directly
  â€¢ ${colors.yellow}Disable${colors.reset} for maximum security (use GitHub Actions workflows)
    `,
  },
  {
    title: 'Step 6: Custom Domain + HTTPS (Optional)',
    content: () => `
${colors.cyan}Enable custom domain with automatic HTTPS${colors.reset}

${colors.bright}What this provides:${colors.reset}
â€¢ Custom domain (e.g., ${colors.blue}app.yourdomain.com${colors.reset})
â€¢ Automatic HTTPS/SSL certificates
â€¢ Cloudflare CDN and DDoS protection

${colors.bright}Requirements:${colors.reset}
â€¢ Cloudflare account (free tier works)
â€¢ Domain registered and added to Cloudflare
â€¢ Cloudflare API token with: Account > Cloudflare Tunnel > Edit, Zone > DNS > Edit

${colors.bright}Current Configuration:${colors.reset}
  Custom Domain: ${config.cloudflare.enabled ? `${colors.green}Enabled${colors.reset}` : `${colors.dim}Disabled${colors.reset}`}
${config.cloudflare.domainName ? `  Domain: ${colors.cyan}${config.cloudflare.domainName}${colors.reset}` : ''}
${config.cloudflare.enabled ? `  ${colors.dim}(Domain saved to terraform.tfvars, API token for GitHub Secrets)${colors.reset}` : ''}

${colors.yellow}Keys:${colors.reset}
  ${colors.green}[E]${colors.reset} Enable/Disable custom domain
  ${colors.blue}[C]${colors.reset} Configure domain settings (when enabled)

${colors.dim}Note: Wizard collects API token to display in Step 8 for GitHub Secrets.
API token is NOT saved to terraform.tfvars (security).${colors.reset}

${colors.bright}Recommendation:${colors.reset}
  â€¢ ${colors.green}Enable${colors.reset} if you want professional HTTPS URLs
  â€¢ ${colors.yellow}Skip${colors.reset} if IP address access is sufficient
    `,
  },
  {
    title: 'Step 7: Get API Tokens',
    content: () => {
      let cloudflareInstructions = '';
      if (config.cloudflare.enabled) {
        cloudflareInstructions = `
${colors.bright}Cloudflare API Token${colors.reset} ${colors.dim}(Optional - for custom domain + HTTPS)${colors.reset}
1. Go to: https://dash.cloudflare.com/profile/api-tokens
2. Click "Create Token"
3. Use "Edit zone DNS" template
4. Select your zone/domain
5. Copy the API token
6. Zone ID: Found on domain overview page in Cloudflare dashboard

`;
      }

      return `
${colors.cyan}Collect API tokens from each service${colors.reset}

${colors.bright}Hetzner API Token${colors.reset} ${colors.yellow}(Required)${colors.reset}
1. Go to: https://console.hetzner.cloud/
2. Select your project (or create one)
3. Go to Security â†’ API Tokens
4. Click "Generate API Token"
5. Name: "vibe-vps-deploy"
6. Permissions: ${colors.bright}Read & Write${colors.reset}
7. Copy the token (you won't see it again!)

${cloudflareInstructions}${colors.bright}healthchecks.io API Key${colors.reset} ${colors.dim}(Optional)${colors.reset}
1. Go to: https://healthchecks.io/projects/
2. Click your project
3. Go to Settings â†’ API Access
4. Copy the API key

${colors.green}âœ“ Checkpoint:${colors.reset} API tokens copied and ready to paste
`;
    },
  },
  {
    title: 'Step 8: Configure GitHub Secrets',
    content: () => {
      const keys = sshKeysExist() ? getSSHKeys() : null;

      let sshInstructions = '';
      if (keys) {
        sshInstructions = `
${colors.yellow}SSH_PUBLIC_KEY${colors.reset}
  ${colors.green}âœ“ Auto-generated${colors.reset} - Copy this value:
  ${colors.dim}${keys.publicKey.trim()}${colors.reset}

${colors.yellow}SSH_PRIVATE_KEY${colors.reset}
  ${colors.green}âœ“ Auto-generated${colors.reset} - Copy this ENTIRE value:
  ${colors.dim}${keys.privateKey.split('\n').slice(0, 2).join('\n')}
  ... (${keys.privateKey.split('\n').length} lines total)
  ${keys.privateKey.split('\n').slice(-1)[0]}${colors.reset}
  ${colors.yellow}âš  Include ALL lines from BEGIN to END${colors.reset}
`;
      } else {
        sshInstructions = `
${colors.yellow}SSH_PUBLIC_KEY${colors.reset}
  Paste output from: ${colors.dim}cat ~/.ssh/id_ed25519.pub${colors.reset}

${colors.yellow}SSH_PRIVATE_KEY${colors.reset}
  Paste ENTIRE output from: ${colors.dim}cat ~/.ssh/id_ed25519${colors.reset}
  ${colors.dim}(Must include "-----BEGIN" and "-----END" lines)${colors.reset}
`;
      }

      let cloudflareSecrets = '';
      if (config.cloudflare.enabled) {
        cloudflareSecrets = `
${colors.yellow}CLOUDFLARE_API_TOKEN${colors.reset} ${colors.dim}(Optional - for custom domain)${colors.reset}
  ${config.cloudflare.apiToken ? `${colors.green}âœ“ From wizard${colors.reset} - Copy this value:\n  ${colors.dim}${config.cloudflare.apiToken}${colors.reset}` : 'Paste your Cloudflare API token'}
  ${colors.dim}(or skip if not using custom domain)${colors.reset}

${colors.yellow}CLOUDFLARE_ACCOUNT_ID${colors.reset} ${colors.dim}(Optional - for custom domain)${colors.reset}
  ${config.cloudflare.accountId ? `${colors.green}âœ“ From wizard${colors.reset} - Copy this value:\n  ${colors.dim}${config.cloudflare.accountId}${colors.reset}` : 'Paste your Cloudflare Account ID'}
  ${colors.dim}(Find in Cloudflare dashboard â†’ Account ID)${colors.reset}

${colors.dim}Note: API token and Account ID are NOT saved to terraform.tfvars (security).
Only goes to GitHub Secrets.${colors.reset}

`;
      }

      return `
${colors.cyan}Add secrets to your GitHub repository${colors.reset}

${colors.bright}Navigate to Secrets:${colors.reset}
1. Go to your forked repository on GitHub
2. Click Settings â†’ Secrets and variables â†’ Actions
3. Click "New repository secret" for each:

${colors.bright}Required Secrets (4):${colors.reset}

${colors.yellow}HETZNER_TOKEN${colors.reset}
  Paste your Hetzner API token

${sshInstructions}
${colors.yellow}HEALTHCHECKS_API_KEY${colors.reset}
  Paste your healthchecks.io API key
  ${colors.dim}(or leave empty if not using monitoring)${colors.reset}

${cloudflareSecrets}${getDatabaseSecretsContent()}

${colors.dim}Note: The SSH user is always "deploy" - automatically configured, no secret needed.${colors.reset}

${keys ? `${colors.yellow}Keys:${colors.reset}\n  ${colors.green}[K]${colors.reset} View full SSH keys for copying\n\n` : ''}${colors.green}âœ“ Checkpoint:${colors.reset} All secrets added to GitHub
`;
    },
  },
  {
    title: 'Step 9: Run Infrastructure Workflow',
    content: `
${colors.cyan}Provision your VPS using GitHub Actions${colors.reset}

${colors.bright}Run the workflow:${colors.reset}
1. Go to your repository â†’ Actions tab
2. Click "${colors.bright}Provision Infrastructure${colors.reset}" in left sidebar
3. Click "Run workflow" dropdown (right side)
4. Keep "Branch: main" selected
5. Leave "Destroy infrastructure" ${colors.bright}unchecked${colors.reset}
6. Click green "Run workflow" button

${colors.bright}What happens (4-5 minutes):${colors.reset}
  ${colors.green}âœ“${colors.reset} Terraform provisions VPS on Hetzner
  ${colors.green}âœ“${colors.reset} Cloud-init installs Docker
  ${colors.green}âœ“${colors.reset} Firewall configured
  ${colors.green}âœ“${colors.reset} Deploy user created

${colors.bright}When complete:${colors.reset}
  â€¢ Click on the workflow run
  â€¢ Click "Summary"
  â€¢ ${colors.yellow}Copy the VPS_HOST IP address${colors.reset}
  â€¢ ${colors.yellow}Copy the HEALTHCHECK_PING_URL${colors.reset} (if shown)

${colors.green}âœ“ Checkpoint:${colors.reset} Infrastructure provisioned successfully
    `,
  },
  {
    title: 'Step 10: Add Deployment Secrets',
    content: () => `
${colors.cyan}Configure secrets for automatic deployments${colors.reset}

${colors.bright}Add the secrets displayed in the workflow summary:${colors.reset}

1. Go to Settings â†’ Secrets and variables â†’ Actions
2. Click "New repository secret"

${colors.yellow}VPS_HOST${colors.reset}
  Paste the IP address from workflow summary

${colors.yellow}HEALTHCHECK_PING_URL${colors.reset} ${colors.dim}(Optional)${colors.reset}
  Paste the ping URL from workflow summary
  ${colors.dim}(or skip if not using monitoring)${colors.reset}

${config.cloudflare.enabled ? `\n${colors.yellow}CLOUDFLARE_TUNNEL_TOKEN${colors.reset} ${colors.dim}(Optional - for custom domain)${colors.reset}\n  Paste the Cloudflare tunnel token from workflow summary\n  ${colors.dim}(or skip if not using custom domain)${colors.reset}\n\n${colors.yellow}CUSTOM_DOMAIN_URL${colors.reset} ${colors.dim}(Optional - for custom domain)${colors.reset}\n  Paste your custom domain URL (e.g., https://app.example.com)\n  ${colors.dim}(or skip if not using custom domain)${colors.reset}\n\n${colors.dim}Don't forget to uncomment the cloudflared service in deploy/docker-compose.yml!${colors.reset}\n\n` : ''}${colors.green}âœ“ Checkpoint:${colors.reset} Deployment secrets configured

${colors.bright}Now automatic deployments will work!${colors.reset}
    `,
  },
  {
    title: 'Step 11: Deploy Your Application',
    content: `
${colors.cyan}Trigger your first deployment${colors.reset}

${colors.bright}Push code to deploy:${colors.reset}

  git commit --allow-empty -m "trigger first deployment"
  git push origin main

${colors.bright}Watch the deployment:${colors.reset}
1. Go to Actions â†’ "Deploy to VPS" workflow
2. Click on the running workflow
3. Watch it build and deploy (2-3 minutes)

${colors.bright}What happens:${colors.reset}
  ${colors.green}âœ“${colors.reset} Builds Docker image
  ${colors.green}âœ“${colors.reset} Pushes to GitHub Container Registry
  ${colors.green}âœ“${colors.reset} Deploys to your VPS
  ${colors.green}âœ“${colors.reset} Pings healthchecks.io (if configured)

${colors.green}âœ“ Checkpoint:${colors.reset} First deployment complete!
    `,
  },
  {
    title: 'Step 12: Verify Your Deployment',
    content: () => `
${colors.cyan}Check that your app is running${colors.reset}

${colors.bright}Access your app:${colors.reset}
Open in browser: ${config.cloudflare.enabled ? `${colors.blue}${config.cloudflare.domainName}${colors.reset} (HTTPS)\n  ${colors.dim}or ${colors.blue}http://YOUR_VPS_IP${colors.reset}` : `${colors.blue}http://YOUR_VPS_IP${colors.reset}`}

${colors.bright}You should see:${colors.reset}
  {
    "message": "Hello from vibe_in_vps!",
    "timestamp": "...",
    "environment": "production"
  }

${colors.bright}Check health endpoint:${colors.reset}
  ${config.cloudflare.enabled ? `${colors.blue}${config.cloudflare.domainName}/health${colors.reset}\n  ${colors.dim}or ${colors.blue}http://YOUR_VPS_IP/health${colors.reset}` : `${colors.blue}http://YOUR_VPS_IP/health${colors.reset}`}

${colors.bright}SSH to your server:${colors.reset}
  ssh deploy@YOUR_VPS_IP

${colors.green}âœ“ Checkpoint:${colors.reset} App deployed and accessible!
    `,
  },
  {
    title: 'Setup Complete! ðŸŽ‰',
    content: `
${colors.green}${colors.bright}Congratulations! Your zero-ops deployment is live!${colors.reset}

${colors.cyan}What you've set up:${colors.reset}
  ${colors.green}âœ“${colors.reset} VPS running on Hetzner (~$7.50/month)
  ${colors.green}âœ“${colors.reset} Automatic deployments on every push
  ${colors.green}âœ“${colors.reset} Docker + Docker Compose environment
  ${colors.green}âœ“${colors.reset} GitHub Deployments tracking
  ${colors.green}âœ“${colors.reset} Optional uptime monitoring

${colors.cyan}Next steps:${colors.reset}

${colors.bright}1. Deploy your own app${colors.reset}
   â†’ Replace contents of /app directory
   â†’ Ensure Dockerfile exposes port 3000
   â†’ Add /health endpoint
   â†’ git push to deploy!

${colors.bright}2. Customize your infrastructure${colors.reset}
   â†’ Edit infra/terraform/variables.tf
   â†’ Change server type, firewall rules, etc.
   â†’ Re-run Provision Infrastructure workflow

${colors.bright}3. Learn more${colors.reset}
   â†’ ${colors.blue}docs/RUNBOOK.md${colors.reset} - Operations guide
   â†’ ${colors.blue}docs/CONTRIBUTING.md${colors.reset} - Development guide
   â†’ ${colors.blue}CLAUDE.md${colors.reset} - Architecture decisions

${colors.yellow}Need help?${colors.reset}
  â€¢ Check docs/SETUP.md for detailed troubleshooting
  â€¢ Open an issue on GitHub
  â€¢ Review the operations runbook

${colors.bright}Happy deploying! ðŸš€${colors.reset}
    `,
  },
];

// Load config on startup
const config = loadConfig();

// Helper: Get database selection display
function getDatabaseSelectionDisplay() {
  const dbs = config.databases;
  const pg = dbs.postgresql ? `${colors.green}[âœ“] PostgreSQL${colors.reset}` : `${colors.dim}[ ] PostgreSQL${colors.reset}`;
  const mysql = dbs.mysql ? `${colors.green}[âœ“] MySQL${colors.reset}` : `${colors.dim}[ ] MySQL${colors.reset}`;
  const redis = dbs.redis ? `${colors.green}[âœ“] Redis${colors.reset}` : `${colors.dim}[ ] Redis${colors.reset}`;

  return `
${colors.bright}Current Selection:${colors.reset}
  ${pg}     - Relational database (recommended for most apps)
  ${mysql}         - Alternative relational database
  ${redis}          - In-memory cache and message broker
`;
}

// Helper: Get database secrets content
function getDatabaseSecretsContent() {
  const dbs = config.databases;
  const hasAnyDatabase = dbs.postgresql || dbs.mysql || dbs.redis;

  if (!hasAnyDatabase) {
    return '';
  }

  let content = `\n${colors.bright}Database Secrets:${colors.reset} ${colors.dim}(Required if you selected databases)${colors.reset}\n`;

  if (dbs.postgresql) {
    content += `
${colors.yellow}POSTGRES_PASSWORD${colors.reset}
  Generate: ${colors.dim}openssl rand -base64 32${colors.reset}
  Paste the generated password
`;
  }

  if (dbs.mysql) {
    content += `
${colors.yellow}MYSQL_ROOT_PASSWORD${colors.reset}
  Generate: ${colors.dim}openssl rand -base64 32${colors.reset}
  Paste the generated password
`;
  }

  if (dbs.redis) {
    content += `
${colors.yellow}REDIS_PASSWORD${colors.reset}
  Generate: ${colors.dim}openssl rand -base64 32${colors.reset}
  Paste the generated password
`;
  }

  return content;
}

// State
let currentStep = 0;
let waitingForAnyKey = false;

// Clear screen
function clearScreen() {
  process.stdout.write('\x1Bc');
}

// Display step
function displayStep() {
  clearScreen();

  const step = steps[currentStep];
  const progress = `Step ${currentStep + 1} of ${steps.length}`;
  const content = typeof step.content === 'function' ? step.content() : step.content;

  console.log(`${colors.dim}${'='.repeat(80)}${colors.reset}`);
  console.log(`${colors.bright}${step.title}${colors.reset}`);
  console.log(`${colors.dim}${progress}${colors.reset}`);
  console.log(`${colors.dim}${'='.repeat(80)}${colors.reset}`);
  console.log(content);
  console.log(`${colors.dim}${'â”€'.repeat(80)}${colors.reset}`);

  // Navigation hints
  const nav = [];
  if (currentStep > 0) nav.push(`${colors.blue}[P]revious${colors.reset}`);
  if (currentStep < steps.length - 1) nav.push(`${colors.green}[N]ext${colors.reset}`);
  nav.push(`${colors.yellow}[Q]uit${colors.reset}`);

  console.log(`\n${nav.join('  â€¢  ')}\n`);
}

// Handle input
async function handleInput(key) {
  // If we're waiting for any key press, return to step display
  if (waitingForAnyKey) {
    waitingForAnyKey = false;
    displayStep();
    return;
  }

  // SSH key generation (only on Step 3)
  if (currentStep === 3) {
    if (key.toLowerCase() === 'g') {
      // Generate SSH keys
      clearScreen();
      console.log(`${colors.cyan}Generating SSH keys...${colors.reset}\n`);
      const success = await generateSSHKeys();

      if (success) {
        const keys = getSSHKeys();
        console.log(`${colors.green}âœ“ SSH keys generated successfully!${colors.reset}\n`);
        console.log(`${colors.bright}Public key:${colors.reset}`);
        console.log(`${colors.dim}${keys.publicKey}${colors.reset}`);
        console.log(`${colors.bright}Private key:${colors.reset} ${colors.dim}.ssh/id_ed25519${colors.reset}\n`);
        console.log(`${colors.yellow}These keys will be automatically used in Step 6${colors.reset}\n`);
      } else {
        console.log(`${colors.yellow}Failed to generate SSH keys. Please generate manually.${colors.reset}\n`);
      }

      console.log(`Press any key to continue...`);
      waitingForAnyKey = true;
      return; // Wait for next keypress
    } else if (key.toLowerCase() === 'v' && sshKeysExist()) {
      // View existing keys
      const keys = getSSHKeys();
      clearScreen();
      console.log(`${colors.bright}SSH Keys${colors.reset}\n`);
      console.log(`${colors.cyan}Public key:${colors.reset}`);
      console.log(`${colors.dim}${keys.publicKey}${colors.reset}`);
      console.log(`${colors.cyan}Private key location:${colors.reset} ${colors.dim}.ssh/id_ed25519${colors.reset}\n`);
      console.log(`Press any key to continue...`);
      waitingForAnyKey = true;
      return;
    }
  }

  // SSH key viewer (only on Step 8)
  if (currentStep === 8 && key.toLowerCase() === 'k' && sshKeysExist()) {
    const keys = getSSHKeys();
    clearScreen();
    console.log(`${colors.bright}SSH Keys for GitHub Secrets${colors.reset}\n`);
    console.log(`${colors.cyan}SSH_PUBLIC_KEY:${colors.reset}`);
    console.log(`${colors.dim}${keys.publicKey}${colors.reset}`);
    console.log(`${colors.cyan}SSH_PRIVATE_KEY:${colors.reset}`);
    console.log(`${colors.dim}${keys.privateKey}${colors.reset}`);
    console.log(`${colors.yellow}Copy the entire content above for each secret${colors.reset}\n`);
    console.log(`Press any key to continue...`);
    waitingForAnyKey = true;
    return;
  }

  // Database toggle keys (only on Step 4)
  if (currentStep === 3) {
    // Step 4 (index 3) is database selection
    if (key === '1') {
      config.databases.postgresql = !config.databases.postgresql;
      saveConfig(config);
      applyDatabaseConfig();
      displayStep();
      return;
    } else if (key === '2') {
      config.databases.mysql = !config.databases.mysql;
      saveConfig(config);
      applyDatabaseConfig();
      displayStep();
      return;
    } else if (key === '3') {
      config.databases.redis = !config.databases.redis;
      saveConfig(config);
      applyDatabaseConfig();
      displayStep();
      return;
    }
  }

  // SSH access configuration (only on Step 5)
  if (currentStep === 5) {
    // Step 5 (index 5) is SSH access configuration
    if (key.toLowerCase() === 'e') {
      // Toggle direct SSH access
      config.ssh.enableDirectAccess = !config.ssh.enableDirectAccess;
      if (!config.ssh.enableDirectAccess) {
        config.ssh.userIp = ''; // Clear IP when disabling
      }
      saveConfig(config);
      updateTerraformVars(config);
      displayStep();
      return;
    } else if (key.toLowerCase() === 'i' && config.ssh.enableDirectAccess) {
      // Set user IP address
      clearScreen();
      console.log(`${colors.bright}Enter Your IP Address${colors.reset}\n`);
      console.log(`Run this command to get your IP: ${colors.dim}curl ifconfig.me${colors.reset}\n`);
      console.log(`Enter your IP address in CIDR format (e.g., 1.2.3.4/32):`);
      console.log(`${colors.yellow}Press Enter without typing to cancel${colors.reset}\n`);

      // Temporarily disable raw mode and remove keypress listeners
      if (process.stdin.isTTY) {
        process.stdin.setRawMode(false);
      }
      process.stdin.removeAllListeners('keypress');

      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });

      rl.question('Your IP: ', (answer) => {
        rl.close();
        if (answer.trim()) {
          config.ssh.userIp = answer.trim();
          saveConfig(config);
          updateTerraformVars(config);
        }
        // Restore readline setup and display step
        setupReadline();
        displayStep();
      });
      return;
    }
  }

  // Cloudflare configuration (only on Step 6)
  if (currentStep === 6) {
    // Step 6 (index 6) is Cloudflare configuration
    if (key.toLowerCase() === 'e') {
      // Toggle Cloudflare
      config.cloudflare.enabled = !config.cloudflare.enabled;
      if (!config.cloudflare.enabled) {
        // Clear Cloudflare settings when disabling
        config.cloudflare.domainName = '';
        config.cloudflare.apiToken = '';
        config.cloudflare.accountId = '';
        config.cloudflare.zoneId = '';
      }
      saveConfig(config);
      updateTerraformVars(config);
      applyDatabaseConfig(); // Also handles Cloudflare service uncomment/comment
      displayStep();
      return;
    } else if (key.toLowerCase() === 'c' && config.cloudflare.enabled) {
      // Configure Cloudflare settings
      clearScreen();
      console.log(`${colors.bright}Cloudflare Configuration${colors.reset}\n`);
      console.log(`${colors.yellow}We need three values from your Cloudflare account:${colors.reset}\n`);
      console.log(`${colors.dim}Domain/Zone ID â†’ terraform.tfvars (safe to commit)`);
      console.log(`API Token â†’ GitHub Secrets (kept secure)${colors.reset}\n`);

      // Temporarily disable raw mode and remove keypress listeners
      if (process.stdin.isTTY) {
        process.stdin.setRawMode(false);
      }
      process.stdin.removeAllListeners('keypress');

      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });

      rl.question('1. Domain name (e.g., app.example.com): ', (domain) => {
        if (!domain.trim()) {
          rl.close();
          setupReadline();
          displayStep();
          return;
        }

        rl.question('2. Cloudflare API token: ', (apiToken) => {
          if (!apiToken.trim()) {
            rl.close();
            setupReadline();
            displayStep();
            return;
          }

          rl.question('3. Cloudflare Account ID: ', (accountId) => {
            if (!accountId.trim()) {
              rl.close();
              setupReadline();
              displayStep();
              return;
            }

            rl.question('4. Cloudflare Zone ID: ', (zoneId) => {
              rl.close();

              if (zoneId.trim()) {
                config.cloudflare.domainName = domain.trim();
                config.cloudflare.apiToken = apiToken.trim();
                config.cloudflare.accountId = accountId.trim();
                config.cloudflare.zoneId = zoneId.trim();
                saveConfig(config);
                updateTerraformVars(config);

                console.log(`\n${colors.green}âœ“ Cloudflare configuration saved!${colors.reset}\n`);
                setTimeout(() => {
                  setupReadline();
                  displayStep();
                }, 1000);
              } else {
                setupReadline();
                displayStep();
              }
            });
          });
        });
      });

      return;
    }
  }

  switch (key.toLowerCase()) {
    case 'n':
      if (currentStep < steps.length - 1) {
        currentStep++;
        displayStep();
      }
      break;
    case 'p':
      if (currentStep > 0) {
        currentStep--;
        displayStep();
      }
      break;
    case 'q':
      console.log(`\n${colors.yellow}Setup wizard closed.${colors.reset}`);
      console.log(`${colors.dim}You can restart anytime with: npm run setup-wizard${colors.reset}\n`);
      process.exit(0);
      break;
    default:
      // Re-display current step for any unhandled key (provides feedback)
      displayStep();
      break;
  }
}

// Setup readline
function setupReadline() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  // Remove all existing keypress listeners to avoid duplicates
  process.stdin.removeAllListeners('keypress');

  readline.emitKeypressEvents(process.stdin);

  if (process.stdin.isTTY) {
    process.stdin.setRawMode(true);
  }

  process.stdin.on('keypress', (str, key) => {
    if (key.ctrl && key.name === 'c') {
      console.log(`\n\n${colors.yellow}Setup wizard interrupted.${colors.reset}\n`);
      process.exit(0);
    }

    handleInput(key.name);
  });
}

// Main
function main() {
  clearScreen();
  setupReadline();
  displayStep();
}

main();
